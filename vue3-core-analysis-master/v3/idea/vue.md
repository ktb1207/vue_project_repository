### Vue 的设计哲学

我从官网截取了一段对`Vue`的描述:

> Vue 是一套用于构建用户界面的渐进式框架

这样的一句简述似乎也不是那么好理解，但是他提供给我们两个很好的角度来解释`Vue`。

## 1. 渐进式的框架

谈到渐进式，我们先考虑一个问题为什么需要框架呢？尤大曾在`Vue2.0`发布之际的一次演讲中谈到过，框架的存在是为了帮助我们应对复杂度。怎么理解呢？
在前端项目中我们需要解决一些工程上的问题的时候，这些问题会有不同的复杂度。如果使用的工具太过于简陋，其实在应对项目问题的时候，
我们解决问题所需要的复杂度就会更高；框架正是将一些重复的并且经过验证的模式，封装到设计好的`API`中，帮助我们去应对更复杂的问题。
我们考虑到项目工程是有复杂度高低的，但是忽略了框架本身其实也是有复杂度，而渐进式的体现就在于框架本身的复杂度是具有伸缩性的。

##### 如何理解框架本身复杂度的伸缩性？

框架本身的复杂度应该如何理解呢？我需要上一张来自官方的图来辅助讲解：

![渐进式](/vue3-analysis/idea/progress-vue.png)

从图中很明显就能看出从左至右这就是复杂度的一种上升，从`Vue`核心的声明式渲染开始，用户可以选择性的集成更多的系统来构建应用，这里并没有太多的强制性要求，
而是让用户根据项目复杂度来决定框架所需复杂度；当然`Vue`官方为了保证社区不会过于碎片化，
对一些核心模块还是交由官方来维护，以插件的形态存在于`Vue`的生态中。  
如果在你的项目中需要组件化的系统，你能很轻松地通过`Vue`提供的组件化能力来构建系统；如果你需要更加细分化的页面展示
以及更加系统的数据状态管理，`Vue`都会提供一个官方的途径来使得你更加轻松的基于`Vue`开始构建应用；对于开发生产的工程化系统`Vue`
也提供了完备的`vue-cli`工具和一系列的`devtools`；所有的一切都是可选择的、非强制性的。  
这一特性和`React`是很类似的，两者都是关注于视图层的库，都是专注于提供一种构建视图的方式，框架本身能随着项目需求来改变框架本身的复杂度，
从而自如的在不同体量不同复杂度的项目中扮演合适的角色；比如在简单项目中，`Vue`能够仅提供核心的声明式渲染库来降框架的低繁重感，
在复杂的大型应用中也能够集成像路由解决方案、数据管理方案来降低项目的复杂度；
这是渐进式的主要体现也是`Vue`设计中平衡框架复杂度的解决方式。

## 2. 构建用户界面

从刚刚渐进式的解读其实我们很明显的感觉到`Vue`是被自底向上的设计的，核心是声明式渲染，关注于视图层；
那么`Vue`究竟提供了一种什么样的方式来构建用户界面呢？这时候还是的贴上一段`Vue`的代码比较容易理解：

```html
<div id="app">
  {{ message }}
</div>
```

```js
<script>
  var app = new Vue({
    el: '#app',
    data: {
      message: 'Hello Vue!'
    }
  })
</script>
```

#### - 渲染机制

关于模板部分，声明式渲染使得我们能采用较为简洁的模板语法（指令、绑定语法）声明式的将数据渲染进`Dom`；
可能还有很多人非常喜欢`React JSX`的视图构建方式，这其实是动态渲染函数和基于编译的字符串模板系统的技术权衡。

##### 完全的动态渲染函数

完全的动态渲染函数会丢掉编译时优化这一重大性能突破口，虽然`JavaScript`足够快但是没有优化下的运行时还是会做很多不必要的操作，
比如每次更新都需要对比很大一部分非动态的内容（特指`Dom`中未与我们编写的状态形成绑定关系的部分），
因为过于动态的表达方式使得编译阶段根本无法确定动态内容、无法提供有效的优化信息；这也是`React`需要`Fiber`这样可中断式的复杂运行时调度的原因；
但是`JSX`由于拥有`JavaScript`的所有动态性，能够很轻易的构建拥有复杂**UI**逻辑的组件，
`virtual dom`的表现力也能使得`react native`、`taro`这类不同平台拥有`react`的全部表达力和**UI**构建方式。

##### 极致优化的模板系统

模板系统虽然能优化出极致的运行时性能，比如`svelte`的摒弃`virtual dom`层直接将模板编译成命令式的更新语句，实现点对点的更新精准度；
但是也产生了运行时代码的冗余，一处模板的绑定需要编译成挂载时代码、更新时代码和卸载时代码，而相较之下`virtual dom`可能仅需要创建一个虚拟节点，
同时这样的模板系统由于没有`virtual dom`层，动态表现力十分匮乏。

##### `Vue`的选择

`Vue3`的抉择依旧是更加平衡的位置，在保留着`virtual dom`并且同时提供这两种表达视图的方式，
我们书写模板能得到更好的运行时性能，在一些高级场景手写`render`函数能得到更好灵活性。  
`Vue`可以说是非常看重`virtual dom`层带来的表达力，因为从`virtual dom`层能将`Vue`的**UI**构建方式移接到各个平台，
而传统`virtual dom`的性能瓶颈又在于`diff`的时候不可避免的需要深度全量的对比从而大量的占用`CPU`时间，
`Vue3`中另辟蹊径的将模板编译时的信息标记做的更加彻底，使得运行时`virtual dom`性能不再是瓶颈，
同时也保有了手写`render`的灵活性；这样的编译时优化方案使得`Vue`在运行时可以不用做时间切片，运行时的代码也变得更加简洁，
这无不体现了`Vue`在性能与渲染能力上的权衡。

#### - 数据驱动

关于`options API`部分，`Vue`则在背后做了很多处理，将数据与`Dom`绑定关系转化成响应式的关系；这是`Vue`的特点，
也是对于我们思考**UI**方式的一次冲击。

##### 原生的思考方式

```JavaScript
let str = ''
let list = [1, 2, 3, 4]
list.forEach((item) => {
  str += `<li>${item}</li>`
})
// ......
```

##### `Vue`的思考方式

```Vue
<template>
  <ul>
    <li
      v-for="item in list"
      :key="item"
    >
      {{ item }}
    </li>
  </ul>
</template>
<script>
export default {
  data() {
    return {
      list: [1, 2, 3, 4]
    }
  }
}
</script>
```

我们还需要考虑`Dom`操作吗？得益于渲染机制数据就能表达所有的视图，数据驱动视图，这就是当下`mvvm`框架在强调的**UI**是什么。
摒弃语法细节我们更加抽象的思考数据即视图，`Vue`和`React`所表达的视图不就是数据的一种映射吗？  
::: tip 前提

1. 数据即`UI`
2. 数据包含可变的状态和不可变的属性
3. 我们暂且不区分作用和行为之类的概念

:::
> `UI = f(data)`

这样的对于**UI**的表达可能需要一些详尽的讨论才能更好理解，我们放在下一篇去讨论，
但是至少很容易对应起来`Vue`在做的事情就是完成了这个函数的映射功能，也就是在强调视图即数据；
至少`Vue`提供给我们这样一种数据驱动视图的思考**UI**的方式。

## 总结

让我们现在再通过自己的语言来总结一下`Vue`是什么这个问题：`Vue`是一个关注在视图层的框架，
它为我们提供了一种响应式的描述`UI`的方式，并且对于`Vue`本身来说它是具有伸缩性的能动态调节自身复杂度以适应不同的业务复杂度。  
我们现在已经能够回答什么是`Vue`了，似乎也体会到了一点点`Vue`的设计理念——基于响应式数据驱动视图的思考方式和平衡至上的渐进式框架设计，
在讨论响应式系统和模板系统之前，我们先来聊一下**UI**是什么？

## 参考资料

- [尤雨溪论 JavaScript 框架设计哲学：平衡](https://www.bilibili.com/video/BV134411c7Sk)
